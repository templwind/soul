package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// EmailTemplate represents a row from 'public.email_templates'.
type EmailTemplate struct {
	ID           Xid       `json:"id" db:"id" form:"id"`                                     // id
	AccountID    int64     `json:"account_id" db:"account_id" form:"account_id"`             // account_id
	Name         string    `json:"name" db:"name" form:"name"`                               // name
	Subject      string    `json:"subject" db:"subject" form:"subject"`                      // subject
	EmailTypeID  int64     `json:"email_type_id" db:"email_type_id" form:"email_type_id"`    // email_type_id
	Content      string    `json:"content" db:"content" form:"content"`                      // content
	CreatedAt    time.Time `json:"created_at" db:"created_at" form:"created_at"`             // created_at
	UpdatedAt    time.Time `json:"updated_at" db:"updated_at" form:"updated_at"`             // updated_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [EmailTemplate] exists in the database.
func (et *EmailTemplate) Exists() bool {
	return et._exists
}

// Deleted returns true when the [EmailTemplate] has been marked for deletion
// from the database.
func (et *EmailTemplate) Deleted() bool {
	return et._deleted
}

// Insert inserts the [EmailTemplate] to the database.
func (et *EmailTemplate) Insert(ctx context.Context, db DB) error {
	switch {
	case et._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case et._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.email_templates (` +
		`id, account_id, name, subject, email_type_id, content, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)`
	// run
	logf(sqlstr, et.ID, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, et.ID, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	et._exists = true
	return nil
}

// Update updates a [EmailTemplate] in the database.
func (et *EmailTemplate) Update(ctx context.Context, db DB) error {
	switch {
	case !et._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case et._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.email_templates SET ` +
		`account_id = $1, name = $2, subject = $3, email_type_id = $4, content = $5, created_at = $6, updated_at = $7 ` +
		`WHERE id = $8`
	// run
	logf(sqlstr, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt, et.ID)
	if _, err := db.ExecContext(ctx, sqlstr, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt, et.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [EmailTemplate] to the database.
func (et *EmailTemplate) Save(ctx context.Context, db DB) error {
	if et.Exists() {
		return et.Update(ctx, db)
	}
	return et.Insert(ctx, db)
}

// Upsert performs an upsert for [EmailTemplate].
func (et *EmailTemplate) Upsert(ctx context.Context, db DB) error {
	switch {
	case et._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.email_templates (` +
		`id, account_id, name, subject, email_type_id, content, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`account_id = EXCLUDED.account_id, name = EXCLUDED.name, subject = EXCLUDED.subject, email_type_id = EXCLUDED.email_type_id, content = EXCLUDED.content, created_at = EXCLUDED.created_at, updated_at = EXCLUDED.updated_at `
	// run
	logf(sqlstr, et.ID, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt)
	if _, err := db.ExecContext(ctx, sqlstr, et.ID, et.AccountID, et.Name, et.Subject, et.EmailTypeID, et.Content, et.CreatedAt, et.UpdatedAt); err != nil {
		return logerror(err)
	}
	// set exists
	et._exists = true
	return nil
}

// Delete deletes the [EmailTemplate] from the database.
func (et *EmailTemplate) Delete(ctx context.Context, db DB) error {
	switch {
	case !et._exists: // doesn't exist
		return nil
	case et._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.email_templates ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, et.ID)
	if _, err := db.ExecContext(ctx, sqlstr, et.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	et._deleted = true
	return nil
}

// EmailTemplateByID retrieves a row from 'public.email_templates' as a [EmailTemplate].
//
// Generated from index 'email_templates_pkey'.
func EmailTemplateByID(ctx context.Context, db DB, id Xid) (*EmailTemplate, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, account_id, name, subject, email_type_id, content, created_at, updated_at ` +
		`FROM public.email_templates ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	et := EmailTemplate{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&et.ID, &et.AccountID, &et.Name, &et.Subject, &et.EmailTypeID, &et.Content, &et.CreatedAt, &et.UpdatedAt); err != nil {
		return nil, logerror(err)
	}
	return &et, nil
}

// AccountByAccountID returns the Account associated with the [EmailTemplate]'s (AccountID).
//
// Generated from foreign key 'email_templates_account_id_fkey'.
func (et *EmailTemplate) AccountByAccountID(ctx context.Context, db DB) (*Account, error) {
	return AccountByID(ctx, db, et.AccountID)
}

// EmailTypeByEmailTypeID returns the EmailType associated with the [EmailTemplate]'s (EmailTypeID).
//
// Generated from foreign key 'email_templates_email_type_id_fkey'.
func (et *EmailTemplate) EmailTypeByEmailTypeID(ctx context.Context, db DB) (*EmailType, error) {
	return EmailTypeByID(ctx, db, et.EmailTypeID)
}
