package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"time"
)

// EmailStatusHistory represents a row from 'public.email_status_history'.
type EmailStatusHistory struct {
	ID          int64       `json:"id" db:"id" form:"id"`                                  // id
	AccountID   int64       `json:"account_id" db:"account_id" form:"account_id"`          // account_id
	EmailSendID Xid         `json:"email_send_id" db:"email_send_id" form:"email_send_id"` // email_send_id
	Status      EmailStatus `json:"status" db:"status" form:"status"`                      // status
	ChangedAt   time.Time   `json:"changed_at" db:"changed_at" form:"changed_at"`          // changed_at
	Metadata    []byte      `json:"metadata" db:"metadata" form:"metadata"`                // metadata
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [EmailStatusHistory] exists in the database.
func (esh *EmailStatusHistory) Exists() bool {
	return esh._exists
}

// Deleted returns true when the [EmailStatusHistory] has been marked for deletion
// from the database.
func (esh *EmailStatusHistory) Deleted() bool {
	return esh._deleted
}

// Insert inserts the [EmailStatusHistory] to the database.
func (esh *EmailStatusHistory) Insert(ctx context.Context, db DB) error {
	switch {
	case esh._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case esh._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.email_status_history (` +
		`account_id, email_send_id, status, changed_at, metadata` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`) RETURNING id`
	// run
	logf(sqlstr, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata)
	if err := db.QueryRowContext(ctx, sqlstr, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata).Scan(&esh.ID); err != nil {
		return logerror(err)
	}
	// set exists
	esh._exists = true
	return nil
}

// Update updates a [EmailStatusHistory] in the database.
func (esh *EmailStatusHistory) Update(ctx context.Context, db DB) error {
	switch {
	case !esh._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case esh._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.email_status_history SET ` +
		`account_id = $1, email_send_id = $2, status = $3, changed_at = $4, metadata = $5 ` +
		`WHERE id = $6`
	// run
	logf(sqlstr, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata, esh.ID)
	if _, err := db.ExecContext(ctx, sqlstr, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata, esh.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [EmailStatusHistory] to the database.
func (esh *EmailStatusHistory) Save(ctx context.Context, db DB) error {
	if esh.Exists() {
		return esh.Update(ctx, db)
	}
	return esh.Insert(ctx, db)
}

// Upsert performs an upsert for [EmailStatusHistory].
func (esh *EmailStatusHistory) Upsert(ctx context.Context, db DB) error {
	switch {
	case esh._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.email_status_history (` +
		`id, account_id, email_send_id, status, changed_at, metadata` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`account_id = EXCLUDED.account_id, email_send_id = EXCLUDED.email_send_id, status = EXCLUDED.status, changed_at = EXCLUDED.changed_at, metadata = EXCLUDED.metadata `
	// run
	logf(sqlstr, esh.ID, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata)
	if _, err := db.ExecContext(ctx, sqlstr, esh.ID, esh.AccountID, esh.EmailSendID, esh.Status, esh.ChangedAt, esh.Metadata); err != nil {
		return logerror(err)
	}
	// set exists
	esh._exists = true
	return nil
}

// Delete deletes the [EmailStatusHistory] from the database.
func (esh *EmailStatusHistory) Delete(ctx context.Context, db DB) error {
	switch {
	case !esh._exists: // doesn't exist
		return nil
	case esh._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.email_status_history ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, esh.ID)
	if _, err := db.ExecContext(ctx, sqlstr, esh.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	esh._deleted = true
	return nil
}

// EmailStatusHistoryByID retrieves a row from 'public.email_status_history' as a [EmailStatusHistory].
//
// Generated from index 'email_status_history_pkey'.
func EmailStatusHistoryByID(ctx context.Context, db DB, id int64) (*EmailStatusHistory, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, account_id, email_send_id, status, changed_at, metadata ` +
		`FROM public.email_status_history ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	esh := EmailStatusHistory{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&esh.ID, &esh.AccountID, &esh.EmailSendID, &esh.Status, &esh.ChangedAt, &esh.Metadata); err != nil {
		return nil, logerror(err)
	}
	return &esh, nil
}

// AccountByAccountID returns the Account associated with the [EmailStatusHistory]'s (AccountID).
//
// Generated from foreign key 'email_status_history_account_id_fkey'.
func (esh *EmailStatusHistory) AccountByAccountID(ctx context.Context, db DB) (*Account, error) {
	return AccountByID(ctx, db, esh.AccountID)
}

// EmailSendByEmailSendID returns the EmailSend associated with the [EmailStatusHistory]'s (EmailSendID).
//
// Generated from foreign key 'email_status_history_email_send_id_fkey'.
func (esh *EmailStatusHistory) EmailSendByEmailSendID(ctx context.Context, db DB) (*EmailSend, error) {
	return EmailSendByID(ctx, db, esh.EmailSendID)
}
