package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// OauthState represents a row from 'public.oauth_states'.
type OauthState struct {
	ID           int64         `json:"id" db:"id" form:"id"`                                  // id
	PublicID     NullPublicID  `json:"public_id" db:"public_id" form:"public_id"`             // public_id
	Provider     string        `json:"provider" db:"provider" form:"provider"`                // provider
	UserID       sql.NullInt64 `json:"user_id" db:"user_id" form:"user_id"`                   // user_id
	UserRoleID   sql.NullInt64 `json:"user_role_id" db:"user_role_id" form:"user_role_id"`    // user_role_id
	Data         []byte        `json:"data" db:"data" form:"data"`                            // data
	Used         sql.NullBool  `json:"used" db:"used" form:"used"`                            // used
	JwtGenerated sql.NullBool  `json:"jwt_generated" db:"jwt_generated" form:"jwt_generated"` // jwt_generated
	CreatedAt    sql.NullTime  `json:"created_at" db:"created_at" form:"created_at"`          // created_at
	ExpiresAt    sql.NullTime  `json:"expires_at" db:"expires_at" form:"expires_at"`          // expires_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [OauthState] exists in the database.
func (os *OauthState) Exists() bool {
	return os._exists
}

// Deleted returns true when the [OauthState] has been marked for deletion
// from the database.
func (os *OauthState) Deleted() bool {
	return os._deleted
}

// Insert inserts the [OauthState] to the database.
func (os *OauthState) Insert(ctx context.Context, db DB) error {
	switch {
	case os._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case os._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (primary key generated and returned by database)
	const sqlstr = `INSERT INTO public.oauth_states (` +
		`public_id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`) RETURNING id`
	// run
	logf(sqlstr, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt)
	if err := db.QueryRowContext(ctx, sqlstr, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt).Scan(&os.ID); err != nil {
		return logerror(err)
	}
	// set exists
	os._exists = true
	return nil
}

// Update updates a [OauthState] in the database.
func (os *OauthState) Update(ctx context.Context, db DB) error {
	switch {
	case !os._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case os._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.oauth_states SET ` +
		`public_id = $1, provider = $2, user_id = $3, user_role_id = $4, data = $5, used = $6, jwt_generated = $7, created_at = $8, expires_at = $9 ` +
		`WHERE id = $10`
	// run
	logf(sqlstr, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt, os.ID)
	if _, err := db.ExecContext(ctx, sqlstr, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt, os.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [OauthState] to the database.
func (os *OauthState) Save(ctx context.Context, db DB) error {
	if os.Exists() {
		return os.Update(ctx, db)
	}
	return os.Insert(ctx, db)
}

// Upsert performs an upsert for [OauthState].
func (os *OauthState) Upsert(ctx context.Context, db DB) error {
	switch {
	case os._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.oauth_states (` +
		`id, public_id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`public_id = EXCLUDED.public_id, provider = EXCLUDED.provider, user_id = EXCLUDED.user_id, user_role_id = EXCLUDED.user_role_id, data = EXCLUDED.data, used = EXCLUDED.used, jwt_generated = EXCLUDED.jwt_generated, created_at = EXCLUDED.created_at, expires_at = EXCLUDED.expires_at `
	// run
	logf(sqlstr, os.ID, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt)
	if _, err := db.ExecContext(ctx, sqlstr, os.ID, os.PublicID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt); err != nil {
		return logerror(err)
	}
	// set exists
	os._exists = true
	return nil
}

// Delete deletes the [OauthState] from the database.
func (os *OauthState) Delete(ctx context.Context, db DB) error {
	switch {
	case !os._exists: // doesn't exist
		return nil
	case os._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.oauth_states ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, os.ID)
	if _, err := db.ExecContext(ctx, sqlstr, os.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	os._deleted = true
	return nil
}

// OauthStateByID retrieves a row from 'public.oauth_states' as a [OauthState].
//
// Generated from index 'oauth_states_pkey'.
func OauthStateByID(ctx context.Context, db DB, id int64) (*OauthState, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, public_id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at ` +
		`FROM public.oauth_states ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	os := OauthState{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&os.ID, &os.PublicID, &os.Provider, &os.UserID, &os.UserRoleID, &os.Data, &os.Used, &os.JwtGenerated, &os.CreatedAt, &os.ExpiresAt); err != nil {
		return nil, logerror(err)
	}
	return &os, nil
}

// OauthStateByPublicID retrieves a row from 'public.oauth_states' as a [OauthState].
//
// Generated from index 'oauth_states_public_id_key'.
func OauthStateByPublicID(ctx context.Context, db DB, publicID NullPublicID) (*OauthState, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, public_id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at ` +
		`FROM public.oauth_states ` +
		`WHERE public_id = $1`
	// run
	logf(sqlstr, publicID)
	os := OauthState{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, publicID).Scan(&os.ID, &os.PublicID, &os.Provider, &os.UserID, &os.UserRoleID, &os.Data, &os.Used, &os.JwtGenerated, &os.CreatedAt, &os.ExpiresAt); err != nil {
		return nil, logerror(err)
	}
	return &os, nil
}

// UserTypeByUserRoleID returns the UserType associated with the [OauthState]'s (UserRoleID).
//
// Generated from foreign key 'oauth_states_user_role_id_fkey'.
func (os *OauthState) UserTypeByUserRoleID(ctx context.Context, db DB) (*UserType, error) {
	return UserTypeByID(ctx, db, os.UserRoleID.Int64)
}
