package models

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

// OauthState represents a row from 'public.oauth_states'.
type OauthState struct {
	ID           uuid.UUID     `json:"id" db:"id" form:"id"`                                  // id
	Provider     string        `json:"provider" db:"provider" form:"provider"`                // provider
	UserID       uuid.UUID     `json:"user_id" db:"user_id" form:"user_id"`                   // user_id
	UserRoleID   sql.NullInt64 `json:"user_role_id" db:"user_role_id" form:"user_role_id"`    // user_role_id
	Data         []byte        `json:"data" db:"data" form:"data"`                            // data
	Used         sql.NullBool  `json:"used" db:"used" form:"used"`                            // used
	JwtGenerated sql.NullBool  `json:"jwt_generated" db:"jwt_generated" form:"jwt_generated"` // jwt_generated
	CreatedAt    sql.NullTime  `json:"created_at" db:"created_at" form:"created_at"`          // created_at
	ExpiresAt    sql.NullTime  `json:"expires_at" db:"expires_at" form:"expires_at"`          // expires_at
	// xo fields
	_exists, _deleted bool
}

// Exists returns true when the [OauthState] exists in the database.
func (os *OauthState) Exists() bool {
	return os._exists
}

// Deleted returns true when the [OauthState] has been marked for deletion
// from the database.
func (os *OauthState) Deleted() bool {
	return os._deleted
}

// Insert inserts the [OauthState] to the database.
func (os *OauthState) Insert(ctx context.Context, db DB) error {
	switch {
	case os._exists: // already exists
		return logerror(&ErrInsertFailed{ErrAlreadyExists})
	case os._deleted: // deleted
		return logerror(&ErrInsertFailed{ErrMarkedForDeletion})
	}
	// insert (manual)
	const sqlstr = `INSERT INTO public.oauth_states (` +
		`id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)`
	// run
	logf(sqlstr, os.ID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt)
	if _, err := db.ExecContext(ctx, sqlstr, os.ID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt); err != nil {
		return logerror(err)
	}
	// set exists
	os._exists = true
	return nil
}

// Update updates a [OauthState] in the database.
func (os *OauthState) Update(ctx context.Context, db DB) error {
	switch {
	case !os._exists: // doesn't exist
		return logerror(&ErrUpdateFailed{ErrDoesNotExist})
	case os._deleted: // deleted
		return logerror(&ErrUpdateFailed{ErrMarkedForDeletion})
	}
	// update with composite primary key
	const sqlstr = `UPDATE public.oauth_states SET ` +
		`provider = $1, user_id = $2, user_role_id = $3, data = $4, used = $5, jwt_generated = $6, created_at = $7, expires_at = $8 ` +
		`WHERE id = $9`
	// run
	logf(sqlstr, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt, os.ID)
	if _, err := db.ExecContext(ctx, sqlstr, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt, os.ID); err != nil {
		return logerror(err)
	}
	return nil
}

// Save saves the [OauthState] to the database.
func (os *OauthState) Save(ctx context.Context, db DB) error {
	if os.Exists() {
		return os.Update(ctx, db)
	}
	return os.Insert(ctx, db)
}

// Upsert performs an upsert for [OauthState].
func (os *OauthState) Upsert(ctx context.Context, db DB) error {
	switch {
	case os._deleted: // deleted
		return logerror(&ErrUpsertFailed{ErrMarkedForDeletion})
	}
	// upsert
	const sqlstr = `INSERT INTO public.oauth_states (` +
		`id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`provider = EXCLUDED.provider, user_id = EXCLUDED.user_id, user_role_id = EXCLUDED.user_role_id, data = EXCLUDED.data, used = EXCLUDED.used, jwt_generated = EXCLUDED.jwt_generated, created_at = EXCLUDED.created_at, expires_at = EXCLUDED.expires_at `
	// run
	logf(sqlstr, os.ID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt)
	if _, err := db.ExecContext(ctx, sqlstr, os.ID, os.Provider, os.UserID, os.UserRoleID, os.Data, os.Used, os.JwtGenerated, os.CreatedAt, os.ExpiresAt); err != nil {
		return logerror(err)
	}
	// set exists
	os._exists = true
	return nil
}

// Delete deletes the [OauthState] from the database.
func (os *OauthState) Delete(ctx context.Context, db DB) error {
	switch {
	case !os._exists: // doesn't exist
		return nil
	case os._deleted: // deleted
		return nil
	}
	// delete with single primary key
	const sqlstr = `DELETE FROM public.oauth_states ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, os.ID)
	if _, err := db.ExecContext(ctx, sqlstr, os.ID); err != nil {
		return logerror(err)
	}
	// set deleted
	os._deleted = true
	return nil
}

// OauthStateByID retrieves a row from 'public.oauth_states' as a [OauthState].
//
// Generated from index 'oauth_states_pkey'.
func OauthStateByID(ctx context.Context, db DB, id uuid.UUID) (*OauthState, error) {
	// query
	const sqlstr = `SELECT ` +
		`id, provider, user_id, user_role_id, data, used, jwt_generated, created_at, expires_at ` +
		`FROM public.oauth_states ` +
		`WHERE id = $1`
	// run
	logf(sqlstr, id)
	os := OauthState{
		_exists: true,
	}
	if err := db.QueryRowContext(ctx, sqlstr, id).Scan(&os.ID, &os.Provider, &os.UserID, &os.UserRoleID, &os.Data, &os.Used, &os.JwtGenerated, &os.CreatedAt, &os.ExpiresAt); err != nil {
		return nil, logerror(err)
	}
	return &os, nil
}

// UserByUserID returns the User associated with the [OauthState]'s (UserID).
//
// Generated from foreign key 'oauth_states_user_id_fkey'.
func (os *OauthState) UserByUserID(ctx context.Context, db DB) (*User, error) {
	return UserByID(ctx, db, os.UserID)
}

// UserTypeByUserRoleID returns the UserType associated with the [OauthState]'s (UserRoleID).
//
// Generated from foreign key 'oauth_states_user_role_id_fkey'.
func (os *OauthState) UserTypeByUserRoleID(ctx context.Context, db DB) (*UserType, error) {
	return UserTypeByID(ctx, db, os.UserRoleID.Int64)
}
