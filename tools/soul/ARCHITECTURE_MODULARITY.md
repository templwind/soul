# Backend Modularity Architecture Plan

## 1. Goal

To refactor the Go backend (`starter-kit/backend`) into a modular system where core SaaS functionality is separated from specific "product" logic. This allows product modules to be developed, versioned, and deployed independently while integrating seamlessly with the core backend.

## 2. Core Technology

This plan leverages the existing `soul` framework by enhancing it to natively support module discovery, code generation, and integration.

## 3. Module Location

Product modules will reside within the core backend's directory structure at: `backend/internal/modules/`.

Placing modules within `internal/` allows them to import and utilize core internal packages (like `svc`, `models`, etc.) as needed, which is essential for integration.

## 4. Module Management

- **Independent Repositories:** Each module is developed and maintained in its own separate Git repository.
- **Git Submodules:** Modules are added to the main `starter-kit` project as Git submodules within the designated location:
  ```bash
  # From starter-kit root directory
  git submodule add <module_repo_url> backend/internal/modules/<module_name>
  ```
- **Module `go.mod`:** Each module repository _must_ contain its own `go.mod` file. This file defines the module's Go module path (e.g., `github.com/your-org/product_a`) and its dependencies, including a `require` directive for the core backend module (e.g., `require github.com/your-org/starter-kit/backend v0.0.0`).
- **Module API Definition:** Each module repository _must_ contain an `api/` subdirectory with one or more `.api` files defining the module's specific API services, routes, and types using the `soul` syntax.

## 5. Module Structure Convention

Each module directory (`backend/internal/modules/<module_name>/`) should follow this structure:

- `api/`: Contains the module's `.api` definition file(s).
- `internal/`: Contains Go code generated by `soul` (`handler/`, `logic/`, `types/`, etc.). Developers implement logic here.
- `models/`: Contains the module's GORM model struct definitions (e.g., `models.go`).
- `init/`: Contains module registration logic.
  - `register.go` (or `init.go`): Contains the package `init()` function that calls `dbmodels.RegisterProvider()` (using models from the sibling `models/` package) and `moduleinit.Register()` (using an initializer potentially defined in `initializer.go`).
  - `initializer.go` (Optional): Implements the `moduleinit.Initializer` interface if the module needs custom init/shutdown logic.
- `go.mod`: The module's Go module definition file.

## 6. `soul` Tool Enhancements

The `soul new` command requires the following enhancements to support this architecture:

- **New `modules` Directive:**
  - Recognize a new top-level directive in the root `.api` file (`starter-kit.api`).
  - Syntax: `modules "<glob_pattern>"`
  - Example: `modules "./backend/internal/modules/*"` (Path relative to the root `.api` file).
- **Module Discovery:**
  - Scan the filesystem based on the `modules` directive's glob pattern.
  - Identify valid module directories (subdirectories containing an `api/` subdirectory with `.api` files and an `init/` subdirectory).
  - Handle potential errors gracefully.
- **Relative Code Generation:**
  - Parse the `.api` file(s) found within each discovered module's `api/` directory.
  - Generate the corresponding Go code (types, handlers, logic stubs) into a standard structure _within that module's directory_ (e.g., `backend/internal/modules/<module_name>/internal/...`).
- **Aggregated Route Registration:**
  - Automatically update the central route registration file (`backend/internal/handler/routes.go`).
  - Add necessary import statements for the generated handler packages of each discovered module.
  - Register the routes defined in the module's services using these imported handlers.
- **`go.work` Management:**
  - Automatically detect, create, or update the `go.work` file located at `backend/go.work`.
  - Ensure the `go.work` file includes `use` directives for the core backend (`.`) and every discovered module path relative to `backend/` (e.g., `./internal/modules/product_a`).
- **Generated Registry File:**

  - Automatically create or overwrite a file, e.g., `backend/internal/registry/modules.go`.
  - This file will contain only package comments and the side-effect imports for the `init` package of _every_ discovered module. This ensures module registration functions (`init()`) are triggered without requiring manual edits to core files.
  - _Example `internal/registry/modules.go` (Generated):_

    ```go
    package registry

    // This file is automatically generated by 'soul new'.
    // It triggers module registration via side-effect imports.
    // DO NOT EDIT MANUALLY.

    import (
    	// Discovered module initializers/registrars
    	_ "backend/internal/modules/agentic_cs/init"
    	// _ "backend/internal/modules/another_module/init" // Added automatically
    )
    ```

## 7. Go Workspaces

A `go.work` file located at `backend/go.work` is required for the Go toolchain to correctly resolve dependencies between the main `backend` module and the module submodules during local development. This file will be managed automatically by the enhanced `soul` tool.

_Example `backend/go.work`:_

```
go 1.21 // Use appropriate Go version

use (
    . // Represents the main backend module itself
    ./internal/modules/product_a // Path relative to backend/
    ./internal/modules/product_b
    // Added automatically by 'soul new'
)
```

## 8. Database Schema Management

- **Strategy:** Utilize the existing GORM `AutoMigrate` feature.
- **Interface:** Introduce a simple Go interface and registry (`backend/internal/dbmodels/interface.go`) for modules to declare their GORM models (`dbmodels.ModelProvider`).
- **Module Implementation:** Modules define GORM models in `models/` and register them via `dbmodels.RegisterProvider()` in their `init/register.go`'s `init()` function.
- **Core Integration:**
  - The `backend/internal/database/database.go` file's `InitDatabase` function includes **one** side-effect import: `_ "backend/internal/registry"`. This triggers the `init()` functions in all modules' `init` packages via the generated registry file.
  - It calls `dbmodels.GetAllModels()` to retrieve models registered by modules.
  - It appends the collected module models to the list of core models passed to `svcCtx.DB.AutoMigrate(...)`.

## 9. Module Initialization Hooks

- **Strategy:** Provide optional hooks for modules to run code during application startup and shutdown.
- **Interface:** Define a Go interface and registry (`backend/internal/moduleinit/interface.go`) for module initializers (`moduleinit.Initializer`).
- **Module Implementation:** Modules needing initialization implement the `moduleinit.Initializer` interface and register it via `moduleinit.Register()` in their `init/register.go`'s `init()` function.
- **Core Integration (`backend.go`):**
  - Include **one** side-effect import: `_ "backend/internal/registry"`. This triggers the `init()` functions in all modules' `init` packages via the generated registry file.
  - Call `moduleinit.RunInitializers(svcCtx)` after core services are initialized but before the server starts.
  - Defer `moduleinit.RunShutdowns(svcCtx)` early in `main()`.

## 10. Configuration

- **Primary Source:** Modules should primarily rely on the shared core configuration loaded into `svcCtx.Config` from `etc/backend.yaml`.
- **Module-Specific Config:** If necessary, module-specific configuration keys can be added under a dedicated namespace within `etc/backend.yaml` (e.g., `Modules.ProductA.Setting: value`).

## 11. Directory Structure Visualization

```
starter-kit/
├── backend/
│   ├── internal/
│   │   ├── modules/             # Module Root
│   │   │   └── product_a/       # Example Module (Submodule)
│   │   │   ├── agentic_cs.api      # Module API definition at root
│   │   │       ├── internal/    # Generated by soul
│   │   │       │   ├── handler/
│   │   │       │   ├── logic/
│   │   │       │   └── types/
│   │   │       ├── models/        # Module DB Models
│   │   │       │   └── models.go
│   │   │       ├── init/          # Module Registration & Init Logic
│   │   │       │   └── register.go (contains init())
│   │   │       ├── go.mod         # Module's go.mod
│   │   │       └── ...
│   │   ├── dbmodels/            # Model Provider Interface/Registry
│   │   │   └── interface.go
│   │   ├── moduleinit/          # Initializer Interface/Registry
│   │   │   └── interface.go
│   │   ├── registry/            # NEW: Generated Registry
│   │   │   └── modules.go       # Contains side-effect imports
│   │   ├── handler/             # Core Handlers (routes.go updated by soul)
│   │   ├── logic/               # Core Logic
│   │   ├── models/              # Core Models
│   │   ├── database/            # Imports registry
│   │   └── ... (svc, config, etc.)
│   ├── etc/
│   │   └── backend.yaml
│   ├── go.mod                   # Core backend go.mod
│   ├── go.work                  # Auto-managed by soul
│   └── backend.go               # Imports registry
├── frontend/
├── admin/
├── starter-kit.api            # Contains 'modules' directive
└── Makefile                   # Contains 'make gen' target
```

## 12. Developer Workflow Summary

1.  **Create Module Repo:** Develop the module in its own Git repository, including `go.mod`, `api/*.api`, `models/`, and `init/` directories/files as needed.
2.  **Add Submodule:** Add the module repo as a submodule to `starter-kit` inside `backend/internal/modules/`.
3.  **Run Generator:** Execute `make gen` (or the underlying `soul new` command) from the `starter-kit` root.
    - `soul` discovers the new module via the `modules` directive.
    - `soul` generates the module's Go code (`internal/...`).
    - `soul` updates `backend/internal/handler/routes.go`.
    - `soul` updates `backend/go.work`.
    - `soul` generates/updates `backend/internal/registry/modules.go` with the required side-effect imports.
4.  **Implement Logic:** Fill in the business logic in the generated `logic` files within the module.
5.  **Run Migrations:** Execute the central migration command (which relies on `AutoMigrate` discovering registered models via the triggered `init` functions) to apply core and module schema changes.
6.  **Build/Run:** From the `backend/` directory, run `go build` or `go run .`. The `go.work` file ensures dependencies resolve correctly, and the generated registry ensures module setup functions run.
