// Code generated by soul. DO NOT EDIT.
//

// Define HTTP methods
type Method = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";

// Define content types
type ContentType = "application/json" | "application/x-www-form-urlencoded" | "multipart/form-data";

// Define API error response
interface ApiErrorResponse {
  status: number;
  message: string;
  code?: string;
  details?: unknown;
}

// Define request configuration
interface RequestConfig extends RequestInit {
  contentType?: ContentType;
  customFetch?: typeof fetch;
  timeout?: number;
  retry?: {
    attempts: number;
    delay: number;
  };
}

// Define request options
interface RequestOptions<T = unknown> {
  method: Method;
  url: string;
  data?: T;
  config?: RequestConfig;
}

// Custom error class for API errors
class ApiError extends Error {
  constructor(
    public status: number,
    public message: string,
    public code?: string,
    public details?: unknown
  ) {
    super(message);
    this.name = "ApiError";
  }
}

class ApiClient {
  private baseUrl: string;
  private defaultConfig: RequestConfig;

  constructor(baseUrl: string = '', config: RequestConfig = {}) {
    this.baseUrl = baseUrl;
    this.defaultConfig = {
      contentType: "application/json",
      timeout: 30000,
      retry: { attempts: 1, delay: 1000 },
      ...config
    };
  }

  // Helper function to handle timeout
  private withTimeout = (promise: Promise<Response>, timeout: number): Promise<Response> => {
    return Promise.race([
      promise,
      new Promise<Response>((_, reject) =>
        setTimeout(() => reject(new ApiError(408, "Request timeout")), timeout)
      )
    ]);
  };

  // Helper function to handle retries
  private withRetry = async <T>(
    fn: () => Promise<T>,
    attempts: number,
    delay: number
  ): Promise<T> => {
    let lastError: Error = new Error("No error occurred");

    for (let i = 0; i < attempts; i++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error as Error;
        if (i < attempts - 1) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    throw lastError;
  };

  // The main request function
  private async request<T>({
    method,
    url,
    data,
    config = {},
  }: RequestOptions): Promise<T> {
    const {
      contentType = this.defaultConfig.contentType || "application/json",
      customFetch,
      timeout = this.defaultConfig.timeout || 30000,
      retry = this.defaultConfig.retry || { attempts: 1, delay: 1000 },
      ...restConfig
    } = config;

    const headers = new Headers(restConfig.headers || {});
    headers.set("Accept", "application/json");

    if (method !== "GET") {
      headers.set("Content-Type", contentType);
    }

    const body = method !== "GET" && data
      ? contentType === "application/json"
        ? JSON.stringify(data)
        : data instanceof FormData
          ? data
          : new URLSearchParams(data as Record<string, string>)
      : undefined;

    const finalConfig: RequestInit = {
      method: method.toUpperCase(),
      credentials: "include",
      headers,
      body,
      ...restConfig,
    };

    const makeRequest = async () => {
      const fetchFunc = customFetch || fetch;
      const fullUrl = this.baseUrl + (url || '');

      const response = await this.withTimeout(fetchFunc(fullUrl, finalConfig), timeout);

      if (!response.ok) {
        let errorData: ApiErrorResponse;
        try {
          errorData = await response.json();
        } catch {
          errorData = {
            status: response.status,
            message: response.statusText,
          };
        }
        throw new ApiError(
          response.status,
          errorData.message,
          errorData.code,
          errorData.details
        );
      }

      try {
        return await response.json();
      } catch (error) {
        throw new ApiError(500, "Failed to parse response");
      }
    };

    return this.withRetry(makeRequest, retry.attempts, retry.delay);
  }

  // Typed methods
  get = <T>(url: string, config?: RequestConfig): Promise<T> =>
    this.request({ method: "GET", url, config });

  post = <T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> =>
    this.request({ method: "POST", url, data, config });

  put = <T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> =>
    this.request({ method: "PUT", url, data, config });

  delete = <T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> =>
    this.request({ method: "DELETE", url, data, config });

  patch = <T>(url: string, data?: unknown, config?: RequestConfig): Promise<T> =>
    this.request({ method: "PATCH", url, data, config });
}

// Create and export a default client instance
const client = new ApiClient();

export default client;
export { ApiClient, ApiError, RequestConfig, RequestOptions };
