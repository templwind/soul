---
description: 
globs: 
alwaysApply: false
---
# Soul AST Development Workflow

## Critical Workflow Rules

### Rule 1: Let Soul Generate Code First

**NEVER manually create handler or logic files that Soul should generate.** Always follow this workflow:

1. Define your API endpoints in `.api` files within the `ast/` directory
2. Run `make gen` to generate code from your AST definitions
3. Only then implement business logic in the generated logic files

### Rule 2: Separation of Concerns

Follow the proper separation of concerns:

- **AST Files**: Define API contracts (endpoints, request/response types)
- **Generated Handlers**: Handle HTTP requests, parameter binding, and response formatting
- **Logic Files**: Implement business logic (NO SQL HERE)
- **Models**: Define database entities and encapsulate ALL SQL operations
- **Repository Layer**: Optional abstraction over models (still no direct SQL)

### Rule 3: SQL Belongs in Models Layer ONLY

**NEVER put SQL in logic files or repository layers.** SQL should ONLY exist in the models layer:

1. Use the generated models from tools like XO or GORM
2. Extend models with custom query methods if needed
3. Call model methods from logic files

Example models layer with SQL:

```go
// In internal/models/user.go (generated by XO or similar tool)
package models

import (
    "context"
    "database/sql"
    "errors"
)

// User represents a user in the database
type User struct {
    ID        int64     `db:"id" json:"id"`
    Username  string    `db:"username" json:"username"`
    Email     string    `db:"email" json:"email"`
    CreatedAt time.Time `db:"created_at" json:"createdAt"`
}

// UserByID retrieves a user by ID
func UserByID(ctx context.Context, db XODB, id int64) (*User, error) {
    const sqlstr = `SELECT id, username, email, created_at
                    FROM users
                    WHERE id = $1`
                    
    var user User
    err := db.QueryRowContext(ctx, sqlstr, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.CreatedAt,
    )
    
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrUserNotFound
        }
        return nil, err
    }
    
    return &user, nil
}
```

Logic layer using models (NO SQL here):

```go
// In internal/logic/getuser/getuser.go (generated by Soul, then edited)
func (l *GetUserLogic) GetUser(req *types.GetUserRequest) (resp *types.GetUserResponse, err error) {
    // Initialize response
    resp = &types.GetUserResponse{
        Success: false,
    }
    
    // Use models to get user - NO SQL HERE
    user, err := models.UserByID(l.ctx, l.svcCtx.DB, req.UserID)
    if err != nil {
        l.Logger.Error("Failed to get user", logx.Field("error", err), logx.Field("userID", req.UserID))
        return nil, errors.New("failed to get user")
    }
    
    // Build response
    resp.Success = true
    resp.User = &types.User{
        ID:       user.ID,
        Username: user.Username,
        Email:    user.Email,
    }
    
    return resp, nil
}
```

### Rule 4: Handler Implementation

**NEVER implement handler methods manually.** Soul generates these for you:

```go
// This is generated by Soul - DO NOT IMPLEMENT MANUALLY
func (l *GetUserLogic) GetUserGet(c echo.Context, req *types.GetUserRequest) (resp *types.GetUserResponse, err error) {
    // This is generated and will call your GetUser method
}
```

### Rule 5: Code Generation Workflow

Always follow this workflow when making API changes:

1. Update `.api` files in the `ast/` directory
2. Run `make gen` to regenerate code
3. Implement business logic in the generated logic files
4. Use models for ALL database operations
5. Test your implementation

### Common Mistakes to Avoid

1. ❌ Manually creating handler or logic files
2. ❌ Putting SQL directly in logic files
3. ❌ Putting SQL in repository layers (use models instead)
4. ❌ Implementing handler methods (e.g., `GetUserGet`)
5. ❌ Editing generated files in `internal/handler/` or `internal/types/`
6. ❌ Forgetting to run `make gen` after changing `.api` files

### Best Practices

1. ✅ Define clear API contracts in `.api` files
2. ✅ Run `make gen` after any changes to `.api` files
3. ✅ Implement business logic in generated logic files
4. ✅ Use models for ALL database operations
5. ✅ Use proper error handling and logging 