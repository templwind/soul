---
description: Rules for Docker Compose configuration in the development environment
globs: ["**/compose.yaml", "**/docker-compose.yaml", "**/docker-compose.yml", "**/compose.yml"]
alwaysApply: true
---

# Docker Compose Configuration Guidelines

This MDC file contains rules for maintaining the Docker Compose configuration used in the local development environment, including Postgres, Temporal, and Go application services with AIR for hot-reloading.

## General Compose Configuration

<rule>
name: service_dependencies
description: Enforces proper service dependencies
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
actions:
  - type: suggest
    message: |
      Ensure services have appropriate dependencies:
      
      1. **Explicit Dependencies**:
      - Use `depends_on` to establish service startup order
      - Add health checks for critical dependencies
      
      2. **Healthchecks**:
      - Add health checks for database and critical services
      - Use appropriate retry, interval and timeout values
      - Configure start_period to allow for initial startup time
      
      3. **Dependency Chain**:
      - Migrations should depend on database
      - Application should depend on both database and migrations
      - Services depending on Temporal should wait for Temporal
      
      For example:
      ```yaml
      migrations:
        depends_on:
          postgres:
            condition: service_healthy
        # ...
      
      app:
        depends_on:
          postgres:
            condition: service_healthy
          migrations:
            condition: service_completed_successfully
          temporal:
            condition: service_healthy
        # ...
      ```
examples:
  - input: |
      app:
        depends_on:
          - postgres
          - migrations
    output: |
      app:
        depends_on:
          postgres:
            condition: service_healthy
          migrations:
            condition: service_completed_successfully
  - input: |
      postgres:
        # No healthcheck defined
    output: |
      postgres:
        # ...
        healthcheck:
          test: ["CMD", "pg_isready", "-h", "localhost", "-U", "${POSTGRES_USER}"]
          interval: 10s
          timeout: 5s
          retries: 5
metadata:
  priority: high
  version: 1.0
</rule>

<rule>
name: volume_mounts
description: Enforces proper volume mounts for development
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "volumes:"
actions:
  - type: suggest
    message: |
      Follow these volume mounting best practices:
      
      1. **Development Hot-Reloading**:
      - Mount the entire application directory for AIR hot-reloading
      - Use volume for Go module caching to speed up builds
      
      2. **Database Persistence**:
      - Use named volumes for database data to persist between restarts
      - Mount separate volumes for backup data
      
      3. **Mount Configuration**:
      - Mount configuration files like .env files at runtime
      - Mount scripts directory for helper scripts
      
      4. **Temporal Configuration**:
      - Mount Temporal configuration directories
      
      Example:
      ```yaml
      app:
        volumes:
          - ./app:/app              # For AIR hot-reloading 
          - $GOPATH/pkg:/go/pkg     # Go module cache
          - app_tmp:/app/tmp        # Temporary files
      
      postgres:
        volumes:
          - postgres_data:/var/lib/postgresql/data
          - ./backups:/backups      # Mount for backups
      ```
examples:
  - input: |
      app:
        volumes:
          - ./app:/app
    output: |
      app:
        volumes:
          - ./app:/app              # Application code for hot-reloading
          - $GOPATH/pkg:/go/pkg     # Go module cache
          - app_tmp:/app/tmp        # Temporary files for AIR
  - input: |
      postgres:
        volumes:
          - ./db:/var/lib/postgresql/data
    output: |
      postgres:
        volumes:
          - postgres_data:/var/lib/postgresql/data  # Named volume for persistence
          - ./db/backups:/backups                   # Mount for database backups
metadata:
  priority: medium
  version: 1.0
</rule>

## Go Application Configuration

<rule>
name: air_hot_reload_configuration
description: Enforces proper AIR hot-reload configuration for Go development
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "air|dev"
actions:
  - type: suggest
    message: |
      Configure Go application with AIR for optimal development:
      
      1. **Build Stage**:
      - Use multi-stage builds with dev target
      - Install AIR in the development stage
      
      2. **Environment Variables**:
      - Set GO_ENV=development for development mode
      - Configure log levels appropriately
      
      3. **AIR Configuration**:
      - Mount .air.toml configuration file
      - Specify correct build and run commands
      
      4. **Security Notes**:
      - Use privileged: true only in development
      - Never use privileged in production
      
      Example:
      ```yaml
      app:
        build:
          context: ./app
          target: dev      # Use development target in Dockerfile
        volumes:
          - ./app:/app     # Hot-reload whole directory
        environment:
          - GO_ENV=development
          - LOG_LEVEL=debug
        command: ["air", "-c", ".air.toml"]  # Run with AIR
        privileged: true   # Only for development
      ```
examples:
  - input: |
      app:
        build: ./app
        command: ["/app/bin/app"]
    output: |
      app:
        build:
          context: ./app
          target: dev
        volumes:
          - ./app:/app
        environment:
          - GO_ENV=development
          - LOG_LEVEL=debug
        command: ["air", "-c", ".air.toml"]
        privileged: true  # Development only
  - input: |
      app:
        image: app:latest
    output: |
      app:
        build:
          context: ./app
          target: dev
        volumes:
          - ./app:/app
metadata:
  priority: high
  version: 1.0
</rule>

## Database Configuration

<rule>
name: postgres_configuration
description: Enforces proper PostgreSQL configuration
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "postgres:"
actions:
  - type: suggest
    message: |
      Configure PostgreSQL properly for development:
      
      1. **Environment Variables**:
      - Use environment variables from .env file
      - Set all required Postgres variables
      
      2. **Port Mapping**:
      - Map database port for external tools
      - Consider non-standard ports for multiple databases
      - Use dynamic port allocation to handle port conflicts
      
      3. **Data Persistence**:
      - Use named volumes for data persistence
      - Set appropriate restart policy
      
      4. **Health Checking**:
      - Add proper health checks
      - Set appropriate intervals and timeouts
      
      Example:
      ```yaml
      postgres:
        image: postgres:16
        ports:
          - "${POSTGRES_PORT:-5432}:5432"  # Use alternative port if specified
        env_file:
          - .env
        environment:
          POSTGRES_USER: ${POSTGRES_USER}
          POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          POSTGRES_DB: ${POSTGRES_DB}
        restart: unless-stopped
        volumes:
          - postgres_data:/var/lib/postgresql/data
        healthcheck:
          test: ["CMD", "pg_isready", "-h", "localhost", "-U", "${POSTGRES_USER}"]
          interval: 10s
          timeout: 5s
          retries: 5
      ```
examples:
  - input: |
      postgres:
        image: postgres:latest
        ports:
          - "5432:5432"
        environment:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: app
    output: |
      postgres:
        image: postgres:16  # Specify exact version
        ports:
          - "${POSTGRES_PORT}:5432"
        env_file:
          - .env
        environment:
          POSTGRES_USER: ${POSTGRES_USER}
          POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          POSTGRES_DB: ${POSTGRES_DB}
        restart: unless-stopped
        volumes:
          - postgres_data:/var/lib/postgresql/data
        healthcheck:
          test: ["CMD", "pg_isready", "-h", "localhost", "-U", "${POSTGRES_USER}"]
          interval: 10s
          timeout: 5s
          retries: 5
metadata:
  priority: high
  version: 1.0
</rule>

## Temporal Configuration

<rule>
name: temporal_setup
description: Enforces proper Temporal configuration
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "temporal:"
actions:
  - type: suggest
    message: |
      Configure Temporal services properly:
      
      1. **Version Control**:
      - Use environment variables for Temporal versions
      - Keep UI and Admin tools versions in sync
      
      2. **Database Integration**:
      - Configure Temporal to use PostgreSQL
      - Use the same database service with appropriate credentials
      
      3. **UI and Tools**:
      - Include Temporal UI for development
      - Include admin tools for debugging
      - Configure appropriate port mappings
      
      4. **Configuration**:
      - Mount dynamic configuration files
      - Configure CORS properly for local development
      
      Example:
      ```yaml
      temporal:
        env_file:
          - .env
        depends_on:
          postgres:
            condition: service_healthy
        environment:
          - DB=postgres12
          - DB_PORT=${POSTGRES_PORT}
          - POSTGRES_USER=${POSTGRES_USER}
          - POSTGRES_PWD=${POSTGRES_PASSWORD}
          - POSTGRES_SEEDS=${POSTGRES_HOST}
          - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development-sql.yaml
        image: temporalio/auto-setup:${TEMPORAL_VERSION}
        ports:
          - 7233:7233
        volumes:
          - ./temporal/dynamicconfig:/etc/temporal/config/dynamicconfig
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:7233/health"]
          interval: 10s
          timeout: 5s
          retries: 5
      
      temporal-ui:
        env_file:
          - .env
        depends_on:
          temporal:
            condition: service_healthy
        environment:
          - TEMPORAL_ADDRESS=temporal:7233
          - TEMPORAL_CORS_ORIGINS=http://localhost:3000
        image: temporalio/ui:${TEMPORAL_UI_VERSION}
        ports:
          - 8080:8080
      ```
examples:
  - input: |
      temporal:
        image: temporalio/auto-setup:latest
        ports:
          - 7233:7233
    output: |
      temporal:
        env_file:
          - .env
        depends_on:
          postgres:
            condition: service_healthy
        environment:
          - DB=postgres12
          - DB_PORT=${POSTGRES_PORT}
          - POSTGRES_USER=${POSTGRES_USER}
          - POSTGRES_PWD=${POSTGRES_PASSWORD}
          - POSTGRES_SEEDS=${POSTGRES_HOST}
          - DYNAMIC_CONFIG_FILE_PATH=config/dynamicconfig/development-sql.yaml
        image: temporalio/auto-setup:${TEMPORAL_VERSION}
        ports:
          - 7233:7233
        volumes:
          - ./temporal/dynamicconfig:/etc/temporal/config/dynamicconfig
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:7233/health"]
          interval: 10s
          timeout: 5s
          retries: 5
  - input: |
      # Missing Temporal UI configuration
    output: |
      temporal-ui:
        env_file:
          - .env
        depends_on:
          temporal:
            condition: service_healthy
        environment:
          - TEMPORAL_ADDRESS=temporal:7233
          - TEMPORAL_CORS_ORIGINS=http://localhost:3000
        image: temporalio/ui:${TEMPORAL_UI_VERSION}
        ports:
          - 8080:8080
metadata:
  priority: medium
  version: 1.0
</rule>

## Environment Configuration

<rule>
name: env_variables
description: Enforces proper environment variable usage
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "environment:|env_file:"
actions:
  - type: suggest
    message: |
      Follow these environment variable best practices:
      
      1. **Env File Usage**:
      - Use env_file for common variables
      - Include service-specific variables directly
      
      2. **Variable References**:
      - Use ${VARIABLE} syntax consistently
      - Add defaults for optional variables
      
      3. **Sensitive Information**:
      - Never hardcode sensitive values
      - Reference all credentials from environment
      
      4. **Debugging**:
      - Add development-specific variables
      - Configure appropriate log levels
      
      5. **Port Allocation**:
      - Set default values for ports that can be overridden
      - Allow for dynamic port allocation to handle conflicts
      
      Example:
      ```yaml
      services:
        app:
          env_file:
            - .env
          environment:
            GO_ENV: ${GO_ENV:-development}
            LOG_LEVEL: ${LOG_LEVEL:-debug}
            DSN: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT:-5432}/${POSTGRES_DB}?sslmode=${POSTGRES_SSL_MODE:-disable}
      ```
examples:
  - input: |
      services:
        app:
          environment:
            DB_USER: postgres
            DB_PASS: secret
            DEBUG: "true"
    output: |
      services:
        app:
          env_file:
            - .env
          environment:
            DB_USER: ${POSTGRES_USER}
            DB_PASS: ${POSTGRES_PASSWORD}
            DEBUG: ${DEBUG:-true}
  - input: |
      services:
        app:
          environment:
            DSN: "postgresql://postgres:password@postgres:5432/app"
    output: |
      services:
        app:
          env_file:
            - .env
          environment:
            DSN: postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@${POSTGRES_HOST}:${POSTGRES_PORT}/${POSTGRES_DB}?sslmode=${POSTGRES_SSL_MODE:-disable}
metadata:
  priority: critical
  version: 1.0
</rule>

## Network Configuration

<rule>
name: network_configuration
description: Enforces proper network configuration
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "networks:|network_mode:"
actions:
  - type: suggest
    message: |
      Configure networks properly:
      
      1. **Network Isolation**:
      - Define custom networks for service isolation
      - Group related services in the same network
      
      2. **Network Definition**:
      - Use bridge driver for local development
      - Define networks at the bottom of the compose file
      
      3. **Service Assignment**:
      - Explicitly assign each service to appropriate networks
      - Allow frontend services to access backend services
      
      Example:
      ```yaml
      services:
        app:
          # ...
          networks:
            - backend
        
        postgres:
          # ...
          networks:
            - backend
        
        # Network definitions
        networks:
          backend:
            driver: bridge
      ```
examples:
  - input: |
      services:
        app:
          # No network defined
        postgres:
          # No network defined
    output: |
      services:
        app:
          # ...
          networks:
            - app_network
        
        postgres:
          # ...
          networks:
            - app_network
        
      networks:
        app_network:
          driver: bridge
  - input: |
      services:
        app:
          network_mode: host
    output: |
      services:
        app:
          networks:
            - app_network
        
      networks:
        app_network:
          driver: bridge
metadata:
  priority: medium
  version: 1.0
</rule>

## SvelteKit Frontend Integration

<rule>
name: sveltekit_integration
description: Guidance on integrating SvelteKit frontend with Docker
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
actions:
  - type: suggest
    message: |
      Best practices for SvelteKit integration:
      
      1. **Development Mode**:
      - For local development, run SvelteKit outside Docker with pnpm
      - Configure appropriate CORS headers in backend services
      
      2. **API Connections**:
      - Connect SvelteKit to backend services via localhost
      - Use environment variables for backend URLs
      
      3. **Production Mode**:
      - For production, build static SvelteKit site
      - Serve static build using Golang HTTP server
      
      4. **Documentation**:
      - Add comments in the compose file about SvelteKit setup
      
      Example comment to add:
      ```yaml
      # Note: SvelteKit frontend is run outside Docker using:
      # cd frontend && pnpm dev
      # Backend APIs are exposed to localhost for the frontend
      ```
      
      If you want to include SvelteKit in Docker:
      ```yaml
      frontend:
        build:
          context: ./frontend
          target: dev
        volumes:
          - ./frontend:/app
          - /app/node_modules
        ports:
          - "3000:3000"
        command: ["pnpm", "dev", "--host", "0.0.0.0"]
        environment:
          - PUBLIC_API_URL=http://localhost:8888
      ```
examples:
  - input: |
      # No mention of frontend
    output: |
      # Note: SvelteKit frontend is run outside Docker using:
      # cd frontend && pnpm dev
      # Backend APIs are exposed to localhost for the frontend
      
      services:
        app:
          # ...
          ports:
            - "8888:8888"  # Exposed for SvelteKit frontend access
          environment:
            # ...
            CORS_ALLOWED_ORIGINS: "http://localhost:3000"  # SvelteKit dev server
  - input: |
      frontend:
        image: node:18
        # Inefficient configuration
    output: |
      # Option 1: Run SvelteKit outside Docker (recommended for development)
      
      # Option 2: Include in Docker (if needed)
      frontend:
        build:
          context: ./frontend
          target: dev
        volumes:
          - ./frontend:/app
          - /app/node_modules
        ports:
          - "3000:3000"
        command: ["pnpm", "dev", "--host", "0.0.0.0"]
        environment:
          - PUBLIC_API_URL=http://localhost:8888
metadata:
  priority: medium
  version: 1.0
</rule>

## Logging Configuration

<rule>
name: logging_configuration
description: Enforces proper logging configuration
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "logging:"
actions:
  - type: suggest
    message: |
      Configure logging properly for development:
      
      1. **Development Logs**:
      - Use json-file driver for most services
      - Set appropriate limits for log files
      
      2. **Log Rotation**:
      - Configure max-size and max-file options
      - Prevent log files from consuming too much disk space
      
      3. **Noisy Services**:
      - Consider using "none" driver for very noisy services
      - Use selective logging for development clarity
      
      Example:
      ```yaml
      services:
        app:
          # ...
          logging:
            driver: "json-file"
            options:
              max-size: "10m"
              max-file: "3"
        
        # For noisy services in development
        temporal:
          # ...
          logging:
            driver: "none"
      ```
examples:
  - input: |
      services:
        app:
          # No logging configuration
    output: |
      services:
        app:
          # ...
          logging:
            driver: "json-file"
            options:
              max-size: "10m"
              max-file: "3"
  - input: |
      services:
        temporal:
          logging:
            driver: "json-file"  # Very noisy in development
    output: |
      services:
        temporal:
          # ...
          logging:
            driver: "none"  # Suppress noisy logs in development
metadata:
  priority: low
  version: 1.0
</rule>

## Volume Definitions

<rule>
name: volume_definitions
description: Enforces proper volume definitions
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "volumes:"
actions:
  - type: suggest
    conditions:
      - pattern: "volumes:\\s+(?!\\s*-\\s)[^-]"
        message: "Define volumes properly at the root level of the compose file"
    message: |
      Define volumes properly:
      
      1. **Named Volumes**:
      - Define named volumes at the root level of the compose file
      - Use descriptive names for volumes
      
      2. **Volume Configuration**:
      - Define driver and options as needed
      - Add labels for documentation
      
      3. **Documentation**:
      - Add comments explaining the purpose of each volume
      
      Example:
      ```yaml
      services:
        # ...
      
      volumes:
        # Database storage
        postgres_data:
          driver: local
        
        # Temporal data
        temporal_data:
          driver: local
        
        # Application temporary files
        app_tmp:
          driver: local
      ```
examples:
  - input: |
      services:
        # ...
      # Missing volume definitions
    output: |
      services:
        # ...
      
      volumes:
        # Database storage
        postgres_data:
          driver: local
        
        # Application temporary files
        app_tmp:
          driver: local
  - input: |
      volumes:
        db_data:
    output: |
      volumes:
        # Database persistent storage
        db_data:
          driver: local
metadata:
  priority: medium
  version: 1.0
</rule>

## Port Allocation and Testing

<rule>
name: dynamic_port_allocation
description: Ensures dynamic port allocation to avoid conflicts
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
  - type: content
    pattern: "ports:"
actions:
  - type: suggest
    message: |
      Implement dynamic port allocation to avoid conflicts:
      
      1. **Port Testing Script**:
      - Create a script to test if ports are in use
      - Allocate alternative ports when conflicts are detected
      
      2. **Environment Variables**:
      - Use environment variables with defaults for ports
      - Allow overriding ports from .env file
      
      3. **Implementation**:
      - Add a pre-startup script to test ports
      - Update environment variables dynamically
      
      Example port testing script (`test-ports.sh`):
      ```bash
      #!/bin/bash
      
      # Default ports
      POSTGRES_DEFAULT_PORT=5432
      APP_DEFAULT_PORT=8888
      TEMPORAL_DEFAULT_PORT=7233
      TEMPORAL_UI_DEFAULT_PORT=8080
      
      # Test if port is in use
      test_port() {
        local port=$1
        local service=$2
        local default=$3
        
        if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null ; then
          echo "Port $port for $service is in use."
          
          # Find available port
          local new_port=$(find_available_port $default)
          echo "Assigning $service to port $new_port"
          
          # Update .env file
          if grep -q "${service}_PORT=" .env; then
            sed -i "s/${service}_PORT=.*/${service}_PORT=$new_port/" .env
          else
            echo "${service}_PORT=$new_port" >> .env
          fi
          
          return $new_port
        else
          echo "Port $port for $service is available."
          return $port
        fi
      }
      
      # Find available port starting from base
      find_available_port() {
        local base_port=$1
        local port=$base_port
        
        while lsof -Pi :$port -sTCP:LISTEN -t >/dev/null; do
          port=$((port+1))
        done
        
        echo $port
      }
      
      # Get current ports from env or use defaults
      POSTGRES_PORT=${POSTGRES_PORT:-$POSTGRES_DEFAULT_PORT}
      APP_PORT=${APP_PORT:-$APP_DEFAULT_PORT}
      TEMPORAL_PORT=${TEMPORAL_PORT:-$TEMPORAL_DEFAULT_PORT}
      TEMPORAL_UI_PORT=${TEMPORAL_UI_PORT:-$TEMPORAL_UI_DEFAULT_PORT}
      
      # Test each port
      test_port $POSTGRES_PORT "POSTGRES" $POSTGRES_DEFAULT_PORT
      test_port $APP_PORT "APP" $APP_DEFAULT_PORT
      test_port $TEMPORAL_PORT "TEMPORAL" $TEMPORAL_DEFAULT_PORT
      test_port $TEMPORAL_UI_PORT "TEMPORAL_UI" $TEMPORAL_UI_DEFAULT_PORT
      
      echo "Port allocation complete. Updated .env file with available ports."
      ```
      
      Usage in your project:
      ```yaml
      # In docker-compose.yaml
      services:
        postgres:
          ports:
            - "${POSTGRES_PORT:-5432}:5432"
            
        app:
          ports:
            - "${APP_PORT:-8888}:8888"
            
        # Add similar patterns for other services
      ```
      
      Add instructions to run the port testing script before starting docker-compose:
      ```bash
      # In README or startup script
      ./test-ports.sh && docker-compose up -d
      ```
examples:
  - input: |
      services:
        postgres:
          ports:
            - "5432:5432"  # Hardcoded port
    output: |
      services:
        postgres:
          ports:
            - "${POSTGRES_PORT:-5432}:5432"  # Dynamic port allocation
  - input: |
      services:
        app:
          ports:
            - "8888:8888"  # Hardcoded port
    output: |
      services:
        app:
          ports:
            - "${APP_PORT:-8888}:8888"  # Dynamic port allocation
metadata:
  priority: high
  version: 1.0
</rule>

## Development vs Production Considerations

<rule>
name: development_vs_production
description: Provides guidance on development vs production configurations
filters:
  - type: file_path
    pattern: "compose\\.ya?ml$|docker-compose\\.ya?ml$"
actions:
  - type: suggest
    message: |
      Consider these development vs production differences:
      
      1. **Development Focus**:
      - Mount source code for hot-reloading
      - Use privileged mode for development tools
      - Expose debugging ports
      - Include development tools like pgAdmin
      
      2. **Production Differences**:
      - Never use privileged: true in production
      - Use multi-stage builds with production target
      - Don't mount source code directories
      - Don't expose unnecessary ports
      - Use appropriate restart policies
      
      3. **Documentation**:
      - Add comments indicating development-only configurations
      
      Example comment:
      ```yaml
      # Development-only configuration
      # For production:
      # - Remove privileged: true
      # - Use build target: production
      # - Don't mount source code volumes
      # - Remove debugging ports
      ```
examples:
  - input: |
      app:
        privileged: true  # No comment about development-only
    output: |
      app:
        privileged: true  # Development only - remove for production
  - input: |
      # No clear indication of development configuration
    output: |
      # Development-only Docker Compose configuration
      # For production deployment:
      # - Remove privileged: true settings
      # - Use build target: production
      # - Don't mount source code volumes
      # - Remove debugging ports
metadata:
  priority: medium
  version: 1.0
</rule>