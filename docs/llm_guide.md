# Soul Framework: LLM Guide for Rapid Development

This document provides a concise guide to the Soul framework, designed to be understood and utilized by Large Language Models (LLMs) for rapid web application development in Go.

## 1. Introduction

Soul is a Go web framework designed for building web applications quickly. It leverages:

- **Echo:** A high-performance, extensible Go web framework (`github.com/labstack/echo/v4`) for routing and HTTP handling.
- **Templ:** A Go templating engine for creating type-safe HTML components (`github.com/a-h/templ`).
- **Code Generation:** A CLI tool (`soul`) that generates boilerplate code (routes, handlers, types, logic stubs) from a declarative API specification file (`.api`).

The core philosophy is **Define -> Generate -> Implement**.

## 2. Core Concepts

- **Echo Integration:** Soul builds upon Echo. Routes defined in the spec are mapped to Echo routes and groups. Middleware specified in the spec is applied using Echo's middleware system.
- **Templ Components:** UI is built using `templ` components. Soul provides helpers (`soul.New`, `soul.WithProps`) and a core rendering function (`soul.Render`).
- **`soul.Render`:** The bridge between Echo handlers and Templ components. It takes an `echo.Context`, HTTP status, and a `templ.Component` instance. It handles rendering the component, including layouts and partials defined by themes, and manages the HTTP response. It uses a buffered writer internally, allowing components to set cookies during rendering.
- **Service Context (`svcCtx`):** A central struct (`svc.ServiceContext`) generated by the tool. It holds application-wide dependencies like configuration (`config.Config`), database connections, etc. It's passed down through handlers to the logic layer for dependency injection.
- **Handler -> Logic Pattern:** Generated handlers (`handler/`) are typically thin wrappers. They parse/validate requests, instantiate a corresponding `Logic` struct (`logic/`), call a method on the logic struct to perform the business operation, and then format the response (either JSON or rendering a Templ component via `soul.Render`).
- **Themes:** UI components, layouts, and partials are often organized into themes (directories like `themes/default/`, `themes/backoffice/`). The `@server` directive's `template` property in the `.api` spec determines which theme's components are imported and used by generated handlers.

## 3. Development Workflow

1.  **Define Specification (`*.api` file):** Describe your application's types, routes, middleware, data structures, and server configurations using Soul's DSL in one or more `.api` files.
2.  **Generate Code (`soul` CLI):** Run the `soul` CLI tool (e.g., `soul saas -api your_spec.api -dir .`) to generate the Go project structure, including routing, handlers, logic stubs, type definitions, and service context based on your `.api` file.
3.  **Implement Business Logic:** Fill in the generated function/method stubs in the `logic/` directory with your application's core business logic. Use the provided `svcCtx` to access configuration and dependencies.
4.  **Implement UI (Templ Components):** Create or modify `templ` components, typically within the theme directory specified in your `.api` file (e.g., `themes/your_theme/views/`, `themes/your_theme/partials/`). Handlers generated for GET requests will often render these components.
5.  **Configure:** Set up configuration values in the `etc/` directory (e.g., database connection strings, API keys).
6.  **Run:** Compile and run the generated Go application.

## 4. The `.api` Specification Format

This DSL defines the application structure. Key elements:

- **Type Definitions:**

  ```api
  type LoginForm {
      Email    string `form:"email" validate:"required,email"` // Struct tags for binding, validation
      Password string `form:"password" validate:"required"`
  }

  type User {
      ID   int64  `json:"id"`
      Name string `json:"name"`
  }
  ```

  - Uses Go-like syntax.
  - Supports `json`, `form`, `path`, `validate` tags.

- **Server Groups (`@server`):** Defines settings for a group of services/routes.

  ```api
  @server (
      group:      admin/users // Generated package: handler/admin/users, logic/admin/users
      prefix:     /api/admin  // URL prefix for routes in this group
      middleware: AuthRequired, Logger // Middleware names (must exist in svcCtx)
      template:   admin_theme // Theme directory (e.g., themes/admin_theme/)
      jwt:        AdminAuth   // Enables JWT auth using 'AdminAuth' config section
      languages:  en,fr       // Supported languages
  )
  ```

- **Services (`service ServiceName { ... }`):** Logical grouping of related handlers.

  ```api
  service UserManagement {
      // ... handler definitions ...
  }
  ```

- **Handler/Route Definitions:**

  ```api
  @handler getUser // Base name for handler/logic functions
  @doc ( summary: "Get user details by ID" ) // Optional documentation
  @page ( title: "User Profile", template: "user_profile_view" ) // For HTML page rendering (GET only)
  get /users/:id (GetUserRequest) returns (User) // Method Path (RequestType) returns (ResponseType)

  @handler createUser
  post /users (CreateUserRequest) returns (User) // JSON API example

  @handler listUsers
  get /users // HTML page rendering (uses conventions if @page omitted)

  @handler serveAsset
  get /assets/* // Static file serving (convention)
  ```

  - Annotations (`@handler`, `@page`, `@doc`) precede the route line.
  - Route line: `httpMethod /path/:param (RequestType) returns (ResponseType)`. `RequestType` and `returns (ResponseType)` are optional.
  - Path parameters use `:paramName`.

- **SaaS-Specific Features (Used with `soul saas` generator):**

  - `isStaticEmbed: true`: Embeds static files from the specified path into the binary.
    ```api
    @handler serveEmbeddedAssets
    @static ( embed: true ) // Add this annotation
    get /embedded/*
    ```
  - `staticRouteRewrite: "/new/path"`: Serves static files from the `get` path under a different URL prefix.
  - `isPubSub: true`: Defines a Pub/Sub handler (generated as a background goroutine).
    ```api
    @handler processOrderEvent
    @pubsub ( topic: "orders.created" ) // Add this annotation
    sub /events/orders // 'sub' keyword (or similar convention) + path
    ```

- **Modules (`@modules`):** Import pre-built Soul modules.
  ```api
  @modules (
      module (
          name:       PaymentsModule
          source:     github.com/some/payments // Source URL
          prefix:     /api/payments            // Mount path prefix
          license:    some_license_key         // Optional license
      )
  )
  ```

## 5. Code Generation (`soul` CLI)

- **Commands:**
  - `soul saas -api <spec_file> -dir <output_dir>`: Generates a project with SaaS features (enhanced static files, Pub/Sub).
  - Other commands: `parsexo` (likely DB schema related), `update`, `version`.
- **Generated Structure (Typical):**
  - `app.go`: Main application entry point.
  - `etc/`: Configuration files (`*.yaml`).
  - `handler/`: Generated Echo handlers (thin wrappers). Organized by `group` from spec.
  - `logic/`: Generated business logic stubs (implement logic here). Organized by `group`.
  - `svc/`: Service Context definition (`servicecontext.go`).
  - `types/`: Generated Go structs from type definitions in the spec.
  - `internal/middleware/`: Place for custom middleware implementations.
  - `themes/`: Contains theme directories (e.g., `themes/default/`) with `templ` components (layouts, partials, views).

## 6. Implementation Guide

- **Business Logic:** Implement methods within the generated structs in the `logic/` directory. Use `l.svcCtx` to access config and dependencies.
- **UI (Templ):**
  - Create `.templ` files within the appropriate theme directory (`themes/<theme_name>/...`).
  - Define layouts (e.g., `themes/default/layouts/baseof.templ`) that accept content blocks.
  - Define partials (e.g., `themes/default/partials/header.templ`).
  - Define views (e.g., `themes/default/views/home.templ`) that often wrap themselves in a layout.
  - Generated GET handlers will import and call `soul.Render` with the appropriate view component, which in turn uses the theme's layout.
- **Configuration:** Edit `.yaml` files in `etc/` to provide database credentials, API keys, JWT secrets, etc. The config struct is available via `svcCtx.Config`.

## 7. Minimal Example

**`example.api`:**

```api
type HelloRequest {
    Name string `query:"name"` // Bind from query param
}

type HelloResponse {
    Message string `json:"message"`
}

@server (
    group: api
    prefix: /api
    template: default // Assumes themes/default/ exists
)
service Greeter {
    @handler helloJson
    get /hello (HelloRequest) returns (HelloResponse)

    @handler helloHtml
    @page ( title: "Hello Page" )
    get /hello-page (HelloRequest)
}
```

**Generate:**

```bash
soul saas -api example.api -dir myapp
```

**Implement Logic (`myapp/logic/api/greeterlogic.go`):**

```go
package api

// ... imports ...

type GreeterLogic struct {
	logx.Logger
	ctx    context.Context
	svcCtx *svc.ServiceContext
}

func NewGreeterLogic(ctx context.Context, svcCtx *svc.ServiceContext) *GreeterLogic {
	return &GreeterLogic{
		Logger: logx.WithContext(ctx),
		ctx:    ctx,
		svcCtx: svcCtx,
	}
}

func (l *GreeterLogic) HelloJson(req *types.HelloRequest) (resp *types.HelloResponse, err error) {
	name := "World"
	if req.Name != "" {
		name = req.Name
	}
	resp = &types.HelloResponse{
		Message: fmt.Sprintf("Hello, %s!", name),
	}
	return resp, nil
}

// Logic for helloHtml might just return nil if all data comes from svcCtx or request params
// The handler will take care of rendering the view.
func (l *GreeterLogic) HelloHtml(req *types.HelloRequest) (err error) {
    // Business logic if needed, e.g., fetching data based on req.Name
    // Data needed by the template can be put into echo.Context in the handler
    // before calling soul.Render, or passed directly to the component constructor.
	return nil
}

```

**Implement UI (`myapp/themes/default/views/hellohtml.templ`):**

```templ
package views

import "myapp/themes/default/layouts"
import "myapp/types" // Import generated types if needed

templ HelloHtmlView(name string) {
	@layouts.Base("Hello Page") { // Assuming Base layout exists
		<h1>Hello, { name }!</h1>
		<p>This is rendered via Templ.</p>
	}
}
```

This guide provides the foundational knowledge for an LLM to understand and generate code for the Soul framework based on user requests and `.api` specifications.
